// Generated by CoffeeScript 1.6.1
(function() {
  var EventEmitter, Infinite, async, exec, fs, json, path, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = require('underscore');

  json = require('json-toolkit');

  fs = require('fs-extra');

  path = require('path');

  EventEmitter = require('events').EventEmitter;

  exec = require('child_process').exec;

  async = require('async');

  Infinite = (function(_super) {

    __extends(Infinite, _super);

    function Infinite(folder, options) {
      var _this = this;
      this.options = _.defaults(options || {}, {
        dirname: '.infinite',
        cache_drives: true,
        cache_name: '.inf_cache',
        autoload: true
      });
      this.location = path.resolve(process.cwd(), folder || "", this.options.dirname);
      this.drives = {};
      this.types = {};
      fs.mkdirs(this.location, function(err) {
        if (err) {
          return _this.emit("error", err);
        } else if (_this.options.autoload) {
          return _this.load(function(err) {
            if (err) {
              return _this.emit("error", err);
            } else {
              return _this.emit("ready");
            }
          });
        } else {
          return _this.emit("ready");
        }
      });
    }

    Infinite.prototype.use = function(name) {
      if (_.has(this.drives, name)) {
        return this.drives[name].obj;
      } else {
        return void 0;
      }
    };

    Infinite.prototype.start = function(name, type, cb) {
      var finish,
        _this = this;
      try {
        if (_.isObject(name)) {
          return async.each(_.keys(name), function(key, callback) {
            return _this.start(key, name[key], callback);
          }, function(err) {
            if (_.isFunction(type)) {
              return type(err);
            } else if (err) {
              return _this.emit("error", err);
            }
          });
        }
        if (_.has(this.drives, name)) {
          throw new Error("Drive " + name + " already exists and cannot be overridden.");
        }
        finish = function(obj, file, t) {
          _this.drives[name] = {
            obj: obj,
            file: file,
            type: t
          };
          return _this.saveCache(function(err) {
            if (err) {
              if (_.isFunction(cb)) {
                return cb(err);
              } else {
                return _this.emit("error", err);
              }
            } else {
              if (_.isFunction(cb)) {
                cb(null, obj);
              }
              return _this.emit("start", name, obj, t);
            }
          });
        };
        if (_.isString(type)) {
          if (!_.has(this.types, type)) {
            throw new Error("Unknown drive type " + type + ".");
          }
          return this.types[type].call(this, name, function(err, obj, file) {
            if (err || !_.isObject(obj) || !_.isString(file)) {
              if (!_.isObject(obj)) {
                err = new Error("Expected an object to be returned from type builder.");
              }
              if (!_.isString(file)) {
                err = new Error("Expected the name of a file or directory to be returned from type builder.");
              }
              if (_.isFunction(cb)) {
                return cb(err);
              } else {
                return _this.emit("error", err);
              }
            } else {
              return finish(obj, file, type);
            }
          });
        } else if (_.isObject(type)) {
          return finish(type);
        }
      } catch (err) {
        if (_.isFunction(cb)) {
          return cb(err);
        } else if (err) {
          return this.emit("error", err);
        }
      }
    };

    Infinite.prototype.stop = function(name) {
      if (_.has(this.drives, name)) {
        delete this.drives[name];
        return this.emit("stop", name);
      }
    };

    Infinite.prototype.destroy = function(name, cb) {
      var err,
        _this = this;
      if (_.has(this.drives, name) && (this.drives[name].file != null)) {
        return fs.remove(path.resolve(this.location, this.drives[name].file), function(err) {
          if (err) {
            if (_.isFunction(cb)) {
              return cb(err);
            } else {
              return _this.emit("error", err);
            }
          } else {
            _this.stop(name);
            if (_.isFunction(cb)) {
              cb(null);
            }
            return _this.emit("destroy", name);
          }
        });
      } else {
        err = new Error("Drive does not have an associated file/folder to remove. You will have to remove it manually.");
        if (_.isFunction(cb)) {
          return cb(err);
        } else {
          return this.emit("error", err);
        }
      }
    };

    Infinite.prototype.setType = function(type, build) {
      if (_.has(this.types, type)) {
        throw new Error("Type " + type + " already exists.");
      }
      if (!_.isFunction(build)) {
        throw new Error("Expecting a functions.");
      }
      return this.types[type] = build;
    };

    Infinite.prototype.saveCache = function(cb) {
      var file,
        _this = this;
      if (!this.options.cache_drives) {
        cb();
      }
      file = path.join(this.location, this.options.cache_name);
      return json.saveToFile(_.object(_.keys(this.drives), _.pluck(this.drives, "type")), file, function(err) {
        if (_.isFunction(cb)) {
          return cb(err);
        } else if (err) {
          return _this.emit("error", err);
        }
      });
    };

    Infinite.prototype.load = function(cb) {
      var file,
        _this = this;
      file = path.join(this.location, this.options.cache_name);
      return fs.exists(file, function(exists) {
        if (exists) {
          return json.parseFile(file, function(err, data) {
            if (err) {
              return _this.emit("error", err);
            } else {
              return _this.start(data, function(err) {
                if (_.isFunction(cb)) {
                  return cb(err);
                } else if (err) {
                  return _this.emit("error", err);
                }
              });
            }
          });
        } else if (_.isFunction(cb)) {
          return cb(null);
        }
      });
    };

    return Infinite;

  })(EventEmitter);

  module.exports = Infinite;

}).call(this);
